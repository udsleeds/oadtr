---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

# get osm
```{r}
# libraries
library(tidyverse)
library(osmextract)
library(sf)
```

```{r}
# region_wy = "West Yorkshire"
# tags_needed = c("cycleway",
#                 "bicycle",
#                 "wheelchair",
#                 "kerb",
#                 "disabled",
#                 "mobility_scooter",
#                 "handicap",
#                 "foot",
#                 "lit", 
#                 "access",
#                 "sidewalk",
#                 "footway",
#                 "incline",
#                 "smoothness",
#                 "est_width",
#                 "width",
#                 "ramp",
#                 "sidewalk_left",
#                 "sidewalk_right",
#                 "ramp_wheelchair",
#                 "footway_left",
#                 "footway_right",
#                 "footway_surface",
#                 "priority",
#                 "sidewalk_both_surface",
#                 "sidewalk_both_width",
#                 "path",
#                 "pedestrian",
#                 "sidewalk_left_width",
#                 "sidewalk_right_width",
#                 "sidewalk_right_surface",
#                 "sidewalk_left_surface",
#                 "maxspeed",
#                 "segregated",
#                 "sloped_curb",
#                 "surface",
#                 "tactile_paving",
#                 "crossing"
#                 )
# wy_lines = osmextract::oe_get(
#   place = region_wy,
#   force_download = TRUE,
#   force_vectortranslate = TRUE,
#   extra_tags = tags_needed
# )

# saveRDS(wy_lines,
#         "wy_lines_21-03-2022.RDS")

wy_lines = readRDS(url("https://github.com/udsleeds/openinfra/releases/download/v0.1/wy_lines_21-03-2022.RDS"))

# wy_points = osmextract::oe_get(
#   place = region_wy,
#   layer = "points",
#   force_download = TRUE,
#   force_vectortranslate = TRUE,
#   extra_tags = tags_needed
# )

# saveRDS(wy_points,
#         "wy_points_21-03-2022.RDS")

wy_points = readRDS(url("https://github.com/udsleeds/openinfra/releases/download/v0.1/wy_points_21-03-2022.RDS"))

# osm_query = "SELECT * FROM 'lines', 'points'"
# 
# wy_points_lanes = osmextract::oe_get(
#   place = region_wy,
#   force_download = TRUE,
#   force_vectortranslate = TRUE,
#   extra_tags = tags_needed,
#   query = osm_query
# )

```

```{r}
# join points and lines into one df

# homogenizing columns
# names_lines = wy_lines %>% names 
# names_points = wy_points %>% names
# setdiff(names_lines, names_points)
# setdiff(names_points, names_lines)

wy_lines_short = wy_lines %>% select(-c("waterway",  "aerialway", "z_order"))
wy_points_short = wy_points %>% select(-c("ref", "address", "is_in",   "place"))

wy_joined = rbind(wy_lines_short, wy_points_short)
```


## Function
```{r}
inclusive_mobility_get = function(osm_sf) {
  osm_sf_im = osm_sf %>% 
    # kerb: flush or not
    dplyr::mutate(im_kerb = dplyr::if_else(kerb == "flush", "flush", "other")) %>% 
    # footway is a ‘pavement’ adjacent to a road
    dplyr::mutate(im_footway = dplyr::case_when(
        footway %in% c("left", "right", "both", "sidewalk") |
        sidewalk %in% c("left", "right", "both", "yes", "separate") |
          # trying to capture footways shared with cyclists
          !is.na(cycleway) & # map cycling infrastructure that is an inherent part of the road
          foot %in% c("yes", "designated") |
          segregated %in% "yes"
      ~ "yes",
      TRUE ~ "no" 
    ) 
    ) %>% 
  # footpath is any other right of way for pedestrians, that does not run adjacent to a road.
  dplyr::mutate(im_footpath = dplyr::case_when(
    highway %in% "footway" & 
      im_footway %in% "no" | 
      # not (always) an inherent part of the road
      highway %in% c("cycleway", "bridleway", "path") & # foot = "designated" is implied
      im_footway %in% "no" &
      ! foot %in% c("no", "private") | 
      ! access %in% c("no", "private") &
      segregated %in% "no" # shared space
    ~ "yes",
    TRUE ~ "no"
    )
    ) %>%
    # presence of a crossing: give-way, signal controlled, or none
    dplyr::mutate(im_crossing = dplyr::case_when(
      stringr::str_detect(crossing, "zebra|uncontr|marked")~ "give-way",
      stringr::str_detect(crossing, "toucan|pedex|puffin|equestrian|light|signal")~ "signal-controlled",
      highway %in% "crossing" | footway  %in% "crossing" | !is.na(crossing) ~ "yes",
      TRUE ~ "no"
      )) %>% 
    # implied footways but there's a lack of data to verify
   dplyr::mutate(im_footway_imp = dplyr::case_when(
      im_footway %in% "no" &
        im_footpath %in% "no" &
        im_crossing %in% "no"
      ~ "yes",
      TRUE ~ "no"
    )
  ) %>% 
    # lighting: yes or no
    dplyr::mutate(im_light = dplyr::case_when( 
      highway %in% "street_lamp" |
        ! lit %in% c("no", "disused") & ! is.na(lit)
      ~ "yes",
      TRUE ~ "no"
      )
      ) %>% 
    # recategorize speed
    dplyr::mutate(im_maxspeed = maxspeed %>% 
      parse_number() %>% 
        dplyr::case_when(
          im_maxspeed > 1 & im_maxspeed <= 20 ~ "1-20", # up to 20 mph
          im_maxspeed > 20 & im_maxspeed <= 40 ~ "21-40", # 21 - 40 mph
          im_maxspeed > 40 & im_maxspeed <= 60 ~ "41-60", # 41 - 60 mph
          im_maxspeed > 60 ~ "61", # over 60 mph
    )
  ) %>% 
    # tactile paving: yes, no
    dplyr::mutate(im_tactile = dplyr::case_when(
      ! tactile_paving %in% c("no", "incorrect", "bad") & ! is.na(tactile_paving) 
      ~ "yes",
      ! is.na(tactile_paving)
      ~ "no"
      )
      ) %>% 
    # surface: paved, unpaved, or other
    dplyr::mutate(
      im_surface_paved = dplyr::case_when(
        highway %in% "cycleway"
        ~ "paved",

          stringr::str_detect(surface,
                              "pav|asph|chipseal|concrete|paving|sett|cobble|metal|wood|stepping")
        ~ "paved",
        highway %in% c("footway", "bridleway") & # highway = footway implied surface value is unpaved
          ! surface %in% stringr::str_detect(surface, "pav|asph|chipseal|concrete|paving|sett|cobble|metal|wood|stepping")
        ~ "unpaved",
        stringr::str_detect(surface, "unpav|compact|gravel|rock|pebble|ground|dirt|grass|mud|sand|woodchips|snow|ice|salt")
        ~ "unpaved",
        TRUE & !is.na(surface) ~ "other"
    )
  ) %>% 
    # surface: even  or not
    dplyr::mutate(im_surface = dplyr::case_when(
      stringr::str_detect(surface, "asph|concrete")
      ~ "even",
      
      im_surface_paved %in% "paved" &
        smoothness %in% c("excellent", "good")
      ~ "even",
      ! is.na(im_surface_paved) 
      ~ "uneven"
    )
  ) %>% 
    # width: under 1.5 meters, 1.5-2 meters, or over 2 meters
  dplyr::mutate(
    im_width =  width %>% parse_number(),
    width_cat = case_when(
      width_cl > 0 & width_cl < 1.5 ~ " 1.5",
      width_cl <= 1.5 & width_cl <= 2 ~ "1.5 - 2",
      width_cl > 2 ~ "2 "
    )
  )
}
```

```{r}
wy_im = inclusive_mobility_get(wy_joined)

wy_im %>% pull(im_tactile) %>% table()
```



# Justification

## footways



notes:

- [x] im_footway_pot needs to be updated to exclude crossings
- [] is it possible to download both lines and points at the same time so I don't have to join them?
- [] addressing potential overlaps of crossings (see Park Lane - Westgate)
- [] can illumination level be mapped?
- [] overlaps between points and lines (e.g., adding lit to a highway but then also highway = street_lamp)
- [x] add key:smoothness
- [] im_surface_paved looks bad to me
