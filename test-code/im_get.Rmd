---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

# get osm
```{r}
# libraries
library(tidyverse)
library(osmextract)
library(sf)
```

```{r}
# region_wy = "West Yorkshire"
# tags_needed = c("cycleway",
#                 "bicycle",
#                 "wheelchair",
#                 "kerb",
#                 "disabled",
#                 "mobility_scooter",
#                 "handicap",
#                 "foot",
#                 "lit", 
#                 "access",
#                 "sidewalk",
#                 "footway",
#                 "incline",
#                 "smoothness",
#                 "est_width",
#                 "width",
#                 "ramp",
#                 "sidewalk_left",
#                 "sidewalk_right",
#                 "ramp_wheelchair",
#                 "footway_left",
#                 "footway_right",
#                 "footway_surface",
#                 "priority",
#                 "sidewalk_both_surface",
#                 "sidewalk_both_width",
#                 "path",
#                 "pedestrian",
#                 "sidewalk_left_width",
#                 "sidewalk_right_width",
#                 "sidewalk_right_surface",
#                 "sidewalk_left_surface",
#                 "maxspeed",
#                 "segregated",
#                 "sloped_curb",
#                 "surface",
#                 "tactile_paving",
#                 "crossing"
#                 )
# wy_lines = osmextract::oe_get(
#   place = region_wy,
#   force_download = TRUE,
#   force_vectortranslate = TRUE,
#   extra_tags = tags_needed
# )

# saveRDS(wy_lines,
#         "wy_lines_21-03-2022.RDS")

wy_lines = readRDS(url("https://github.com/udsleeds/openinfra/releases/download/v0.1/wy_lines_21-03-2022.RDS"))

# wy_points = osmextract::oe_get(
#   place = region_wy,
#   layer = "points",
#   force_download = TRUE,
#   force_vectortranslate = TRUE,
#   extra_tags = tags_needed
# )

# saveRDS(wy_points,
#         "wy_points_21-03-2022.RDS")

wy_points = readRDS(url("https://github.com/udsleeds/openinfra/releases/download/v0.1/wy_points_21-03-2022.RDS"))

# osm_query = "SELECT * FROM 'lines', 'points'"
# 
# wy_points_lanes = osmextract::oe_get(
#   place = region_wy,
#   force_download = TRUE,
#   force_vectortranslate = TRUE,
#   extra_tags = tags_needed,
#   query = osm_query
# )

```

```{r}
# join points and lines into one df

# homogenizing columns
# names_lines = wy_lines %>% names 
# names_points = wy_points %>% names
# setdiff(names_lines, names_points)
# setdiff(names_points, names_lines)

wy_lines_short = wy_lines %>% select(-c("waterway",  "aerialway", "z_order"))
wy_points_short = wy_points %>% select(-c("ref", "address", "is_in", "place"))

wy_joined = rbind(wy_lines_short, wy_points_short)
```


## Function
```{r}
inclusive_mobility_get = function(osm_sf) {
  osm_sf_im = osm_sf %>% 
    # kerb: flush or not
    dplyr::mutate(im_kerb = dplyr::if_else(kerb == "flush", "flush", "other")) %>% 
    # footway is a ‘pavement’ adjacent to a road
    dplyr::mutate(im_footway = dplyr::case_when(
        footway %in% c("left", "right", "both", "sidewalk") |
        sidewalk %in% c("left", "right", "both", "yes", "separate") |
          # trying to capture footways shared with cyclists
          !is.na(cycleway) & # map cycling infrastructure that is an inherent part of the road
          foot %in% c("yes", "designated") |
          segregated %in% "yes"
      ~ "yes",
      TRUE ~ "no" 
    ) 
    ) %>% 
  # footpath is any other right of way for pedestrians, that does not run adjacent to a road.
  dplyr::mutate(im_footpath = dplyr::case_when(
    highway %in% "footway" & 
      im_footway %in% "no" | 
      # not (always) an inherent part of the road
      highway %in% c("cycleway", "bridleway", "path") & # foot = "designated" is implied
      im_footway %in% "no" &
      ! foot %in% c("no", "private") | 
      ! access %in% c("no", "private") &
      segregated %in% "no" # shared space
    ~ "yes",
    TRUE ~ "no"
    )
    ) %>%
    # presence of a crossing: give-way, signal controlled, none, or yes (but the type is unknown)
    dplyr::mutate(im_crossing = dplyr::case_when(
      stringr::str_detect(crossing, "zebra|uncontr|marked")~ "give-way",
      stringr::str_detect(crossing, "toucan|pedex|puffin|equestrian|light|signal")~ "signal-controlled",
      highway %in% "crossing" | footway  %in% "crossing" | !is.na(crossing) ~ "yes",
      TRUE ~ "no"
      )) %>% 
    # implied footways but there's a lack of data to verify
   dplyr::mutate(im_footway_imp = dplyr::case_when(
      im_footway %in% "no" &
        im_footpath %in% "no" &
        im_crossing %in% "no"
      ~ "yes",
      TRUE ~ "no"
    )
  ) %>% 
    # lighting: yes or no
    dplyr::mutate(im_light = dplyr::case_when( 
      highway %in% "street_lamp" |
        ! lit %in% c("no", "disused") & ! is.na(lit)
      ~ "yes",
      TRUE ~ "no"
      )
      ) %>% 
    # recategorize speed
    dplyr::mutate(im_maxspeed = maxspeed %>% 
      parse_number() %>% 
        dplyr::case_when(
          im_maxspeed > 1 & im_maxspeed <= 20 ~ "1-20", # up to 20 mph
          im_maxspeed > 20 & im_maxspeed <= 40 ~ "21-40", # 21 - 40 mph
          im_maxspeed > 40 & im_maxspeed <= 60 ~ "41-60", # 41 - 60 mph
          im_maxspeed > 60 ~ "61", # over 60 mph
    )
  ) %>% 
    # tactile paving: yes, no
    dplyr::mutate(im_tactile = dplyr::case_when(
      ! tactile_paving %in% c("no", "incorrect", "bad") & ! is.na(tactile_paving) 
      ~ "yes",
      ! is.na(tactile_paving)
      ~ "no"
      )
      ) %>% 
    # surface: paved, unpaved, or other
    dplyr::mutate(
      im_surface_paved = dplyr::case_when(
        highway %in% "cycleway"
        ~ "paved",

          stringr::str_detect(surface,
                              "pav|asph|chipseal|concrete|paving|sett|cobble|metal|wood|stepping")
        ~ "paved",
        highway %in% c("footway", "bridleway") & # highway = footway implied surface value is unpaved
          ! surface %in% stringr::str_detect(surface, "pav|asph|chipseal|concrete|paving|sett|cobble|metal|wood|stepping")
        ~ "unpaved",
        stringr::str_detect(surface, "unpav|compact|gravel|rock|pebble|ground|dirt|grass|mud|sand|woodchips|snow|ice|salt")
        ~ "unpaved",
        TRUE & !is.na(surface) ~ "other"
    )
  ) %>% 
    # surface: even  or not
    dplyr::mutate(im_surface = dplyr::case_when(
      stringr::str_detect(surface, "asph|concrete")
      ~ "even",
      
      im_surface_paved %in% "paved" &
        smoothness %in% c("excellent", "good")
      ~ "even",
      ! is.na(im_surface_paved) 
      ~ "uneven"
    )
  ) %>% 
    # width: under 1.5 meters, 1.5-2 meters, or over 2 meters
  dplyr::mutate(
    im_width =  width %>% parse_number(),
    width_cat = case_when(
      width_cl > 0 & width_cl < 1.5 ~ " 1.5",
      width_cl <= 1.5 & width_cl <= 2 ~ "1.5 - 2",
      width_cl > 2 ~ "2 "
    )
  )
}
```

```{r}
wy_im = inclusive_mobility_get(wy_joined)

wy_im %>% pull(im_tactile) %>% table()
```

# Justification

## footways

*Inclusive mobility*: pavements adjacent to roads

*OSM*:

- Highway = footway: used for mapping minor pathways which are used mainly or exclusively by pedestrians. 
	- If the footway is associated with a road then add a footway=sidewalk tag. 
		○ https://wiki.openstreetmap.org/wiki/Tag:highway%3Dfootway
- Add the cycleway=* tag to a highway=* to map cycling infrastructure that is an inherent part of the road.
---> If it's part of the road and it's permitted to walk/wheel on, then it's a sidewalk as there's an implication for the sidewalk running next to the carriageway 
- The highway=cycleway tag indicates a separate way for the use of cyclists. 
---> is not clear if highway=cycleway goes adjacent to roads
- There are two main ways of mapping footways, cycleways, and bridleways in the UK
---> see https://wiki.openstreetmap.org/wiki/Classic_vs_Alternative_tagging_schemes_in_use_in_the_United_Kingdom
- Segregated might be used to indicate shared space 
	- https://wiki.openstreetmap.org/wiki/Key:sidewalk
In such cases — where the footway is considered an integral part of the combined foot- and cycleway — sidewalk=* tends to be omitted in favour of segregated=yes 

*Hence*, it can be assumed key:footway and key:sidewalk are associated with the footways going adjacent to the road. Also, given that key:cycleway is supposed to be an inherent part of the road, then it should go adjacent to the road, which implies that if one can wheel/walk on it, then it's a footway too. Moreover, key:segregated might be used instead of sidewalk tag for shared spaces.

## footpaths

*Inclusive Mobility*:

- Any other right of way and not adjacent to roads;

*OSM*:

- Highway = path: This tag is used for paths for which all and any of highway=footway, highway=cycleway and highway=bridleway would be inappropriate or inadequate.
- UK tagging scheme implies that highway values of footways, cycleways, and bridleways are foot = designated
---> https://wiki.openstreetmap.org/wiki/Classic_vs_Alternative_tagging_schemes_in_use_in_the_United_Kingdom

*So*, footpaths should be all the paths that are not footways. 

## implied footways

Sidewalk can be considered a negative tag because it is implied that roads have sidewalks. Yet, given that it is not explicitly mapped so, there is an assumption that might not always be correct. For this reason, a separate column was created to account for that and indicate which highways might have sidewalks but the user, in the end, can make a decision based on the need.

## crossings

*Inclusive Mobility*:

- refers to Traffic Signs Manual
- highlights give-way and signal controlled crossings
- notes that the key qualities of a crossing are safety, convenience, and accessibility
---> it must improve all of them to some extent

*OSM*:

- Can be mapped as nodes with highway=crossing (sidewalks part of the road)
    - https://wiki.openstreetmap.org/wiki/Tag:highway%3Dcrossing
- Can be linestrings with footway = crossing (sidewalks mapped as separate from the road)
		- https://wiki.openstreetmap.org/wiki/Tag:footway%3Dcrossing
- Mapping techniques depend on how the sidewalk was mapped (part of the road or not)

OSM allows to specify the type of a crossing, yet the three approved tags are traffic_lights, uncontrolled, or none. Given this, OSM was recategorized based on the broad categorization of crossings in the IM guide. If the type of a crossing is unknown but it's mapped as present, "yes" value was used, if it is explicitly known that there is no crossing, then "no" value is present.

## tactile paving 

*Inclusive Mobility*:

- outlines 6 different tactile paving surfaces


*OSM*:

- https://wiki.openstreetmap.org/wiki/Key:tactile_paving
- https://wiki.openstreetmap.org/wiki/Talk:Proposed_features/Tactile_paving
- No default value (i.e. existence is not implied)

*So*, OSM does not seem to support the categorization of tactile paving as outlines in the IM guide. For this reason simplified approach was taken in which only the presence or absence of tactile paving is determined.

## Surface

*Inclusive Mobility*:

- Should be: even, firm, and slip-resistant 
---> There are requirements for the joint width (i.e., cobbles unlikely to be suitable) 

*OSM*:

- https://wiki.openstreetmap.org/wiki/Key:surface
- Two main groups:
---> Paved and Unpaved

*So*, it is hard to determine if a given surface matches the requirements of IM guide, especially if it's slip-resistant. For this reason, a simple recategorization was used to only indicate if the surface is even. A basic assumption is that all surfaces, except asphalt and concrete, are not unless they have an excellent or good smoothness level tagged. 


## Notes:

- [x] im_footway_pot needs to be updated to exclude crossings
- [] is it possible to download both lines and points at the same time so I don't have to join them?
- [] addressing potential overlaps of crossings (see Park Lane - Westgate)
- [] can illumination level be mapped?
- [] overlaps between points and lines (e.g., adding lit to a highway but then also highway = street_lamp)
- [x] add key:smoothness
- [x] add key:width
- [] im_surface_paved looks bad to me
- [] add warning if tags are missing
