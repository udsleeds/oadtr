---
title: "SOTM 2022 Workshop - OSM for sustainable transport planning: getting started"
author: "James Hulse, Greta Timiate, Robin Lovelace"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{SOTM2022 Workshop - OSM for sustainable transport planning: getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
# Editor options (for visual mode)
editor_options:
  markdown:
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The [workshop](https://2022.stateofthemap.org/sessions/JEXYHK/) is aimed at everyone interested in using OpenStreetMap (OSM) to support sustainable transport planning, in professional or advocacy contexts.
It demonstrates how to get started with using OSM data representing transport infrastructure for sustainable transport planning, research and policy-making.
It covers how to identify, re-categorize, visualize, and analyze key tags that represent walking, cycling, and wheeling networks.
We also discuss OSM data in the context of other data sources to identify its advantages and limitations.

The workshop is practical and covers the following questions:

1.  What gaps in transport evidence can OSM data fill in different countries?
2.  Which elements and tags are most important for transport planning (and how to get the data in reproducible data science environments)?
3.  How to filter based on different tags and their values?
4.  How to use OSM datasets to visualize transport systems in static and interactive maps?
5.  How to add value to OSM data and communicate results using R, Python and A/B Street, and osm2streets?

To get the most out of the workshop, we recommend installing R, RStudio, and the required packages before the session.
To do this, follow "Installation" section below.
To make sure that everything is installed correctly, run the code in the "Installation Check" section below.
Check [issue 98 on the udsleeds/openinfra repo on GitHub](https://github.com/udsleeds/openinfra/issues/98) (you will need an account to comment) to what you should get after running that code.
Let us know if you have not :)

This workshop assumes no any prior knowledge of R.
We recommend taking a look at online resources like [RStudio's Beginners guide](https://education.rstudio.com/learn/beginner/) and its [Gentle Introduction to Tidy Statistics in R](https://www.rstudio.com/resources/webinars/a-gentle-introduction-to-tidy-statistics-in-r/) if you're new to the language, however.

```{=html}
<!--
This workshop covers: 
* How to download and get OSM data from the R package `osmextract`
* Basics on how the `osmextract` package works
* How to visualise different types of network infrastructure
* How to add value to OSM infrastructure data through the `openinfra` package 
-->
```
# Preparation

## Installing R and RStudio

In this workshop we'll use R, a statistical programming language widely used for data science, modelling and visualisation.
If you are new to R, you should install base R and RStudio before the workshop begins.
<br> There is a great [R and RStudio installation guide](https://rstudio-education.github.io/hopr/starting.html) (Section A.1) by Garrett Grolemund, within [Hands-On Programming with R](https://rstudio-education.github.io/hopr/) for Windows, Mac, and Linux devices.

## Installing Packages

A number of packages will be used within this workshop, though namely [`osmextract`](https://github.com/ropensci/osmextract) and [openinfra](https://github.com/udsleeds/openinfra).

Here are some of the additional packages we will make use of within this workshop:

```{r install_dep, eval = F}
pkgs = c(
  "tmap",    # package for map making
  "sf",      # geographic vector data classes and functions
  "dplyr",   # data manipulation
  "remotes"  # for installing packages from GitHub
  )
```

These can be installed with the following command:

```{r install_okgs, message=FALSE, eval = F}
install.packages(pkgs, repos = "http://cran.us.r-project.org")
```

You can install the development versions of the `osmextract` and `openinfra` packages as follows:

```{r install_dev, message=FALSE, eval = F}
# Enter the lines below into your console to install!
remotes::install_github("ropensci/osmextract", force = T)
remotes::install_github("udsleeds/openinfra")
```

Each package can then be loaded one-by-one as follows:[^1]

[^1]: You can also load all packages at once with:

    ```{r load_pkgs, message=FALSE, eval = F}
    pkgs = c(pkgs, "osmextract", "openinfra")
    lapply(pkgs, library, character.only = TRUE)[length(pkgs)]
    ```

    ## 

```{r, eval = FALSE}
library(tmap)
library(sf)
library(dplyr)
library(remotes)
library(osmextract)
library(openinfra)
```

## Installation Check

If installation has occurred correctly, running the code below locally (on your own device) should successfully create two plots: <br> One 5km radius circular buffer of the infrastructure network around Leeds (UK) City Centre, and <br> Secondly, a test plot just outside of the Institute of Transport Studies (ITS), at the University of Leeds.

```{r install_check, message=FALSE, dpi=300, out.width = '100%', eval = F}
# Pre-installed package data for central Leeds
data = openinfra::sotm_data
# Test osmextract file (ITS Leeds = Institute of Transport Studies, University of Leeds)
test_data = osmextract::oe_get(place = "ITS Leeds")

# Plot central Leeds
tmap::tm_shape(data |> dplyr::select("highway")) + 
  tmap::tm_lines(col = "highway", title.col = "OSM Highways") + 
  tmap::tm_layout( legend.bg.alpha = 0.5, legend.bg.color = "white")

# Plot ITS
tmap::tm_shape(test_data |> dplyr::select("highway")) + 
  tmap::tm_lines(col = "highway", title.col = "OSM Highways") + 
  tmap::tm_layout( legend.bg.alpha = 0.5, legend.bg.color = "white")
```

## Why these packages?

The [`osmextract`](https://github.com/ropensci/osmextract) package is an open source package for downloading and importing large OSM 'extracts' from providers who make the datasets available at national and regional levels.
We can view all `osmextract` available providers with the following:

```{r show_providers, message=FALSE, eval = F}
osmextract::oe_providers() 
```

<br> `osmextract` can currently import datasets from the following providers: [Geofabrik](http://download.geofabrik.de/), [BBBike](https://download.bbbike.org/osm/), and [openstreetmap_fr](https://download.openstreetmap.fr/extracts/).
These provide OSM datasets in the pbf file format .pbf, which is optimized for small file sizes (see the [OSM wiki](https://wiki.openstreetmap.org/wiki/PBF_Format) for details).
<br><br> The [openinfra](https://github.com/udsleeds/openinfra) package, contains several functions to re-categorize OSM infrastructure data from the default key=tag values to friendlier visuals.

[`tmap`](https://r-tmap.github.io/tmap/index.html) is a fantastic package for visualizing geospatial data either statically or interactively.

The [`sf` package](https://r-spatial.github.io/sf/) supports the representation of spatial vector data as simple features which, consequentially, makes spatial analysis much more accessible.
This package is a backbone of geographic vector data in R and the code in this workshop :)

# Getting data

In this section we will use `osmextract` to download OSM data that will be used throughout this workshop.

The `osmextract` package comprises the following core functions (also see a [vignette introducing `osmextract`](https://docs.ropensci.org/osmextract/articles/osmextract.html?q=file%20path#main-package-functions)):

|        Function        | Description                                                            |
|:----------------------------------:|------------------------------------|
|    `oe_providers()`    | Shows a data frame of currently supported OSM data providers           |
|      `oe_match()`      | Matches the input place query with a url from one of the OSM providers |
|    `oe_download()`     | Downloads data from OSM providers                                      |
| `oe_vectortranslate()` | Converts between .pbf (providers default) and .gpkg file formats       |
|      `oe_read()`       | Reads downloaded .pbf and .gpk files into R                            |
|       `oe_get()`       | Performs all of the above in a single function                         |

To start off we will use a generic `oe_get()` function to download data for Leeds, UK. It might take a while.
If you struggle downloading the data or it takes long to compute, then you might use the example dataset (e.g. `data`) for central Leeds.
This is a much smaller dataset, thus making computing much quicker.

```{r, eval = F}
# A useful function is `oe_match_pattern()` to search for patterns in a provider's database. It is helpful in indicating a correct region name for a given provider.
osmextract::oe_match_pattern("leeds") 

leeds = osmextract::oe_get(
  place = "Leeds", # Note capital 'L'!
  provider = "bbbike", # Indicates the provider; default is geofabrik
  layer = "lines", # Default; returns linestring geometries (highways, waterways, aerialways) 
  force_download = TRUE, # Updates the previously downloaded .osm.pbf file (default is FALSE)
  force_vectortranslate = TRUE # Forces the vectorization of a .pbf file to .gpbf even if there is a .gpbf file with the same name (default = FALSE)
)

# have a look at the data
leeds |> dplyr::glimpse()

```

## Tags

In the previous example we've downloaded OSM data but it does not necessarily contain all the information we need.
Indeed, it only has 10 columns and only `highway` column is directly useful for active travel infrastructure planning!

In order to get additional tags we need to specify this as an additional argument before running `oe_get()`.

```{r, eval = F}
# so let's define the extra tags we want

et = c("kerb", "width", "sidewalk", "cycleway", "footway", "lit", "wheelchair", "maxspeed", "foot", "access", "service", "bicycle", "oneway")

leeds = osmextract::oe_get(
  place = "Leeds", # Note capital 'L'!
  provider = "bbbike", # Indicates the provider; default is geofabrik
  layer = "lines", # Default; returns linestring geometries (highways, waterways, aerialways) 
  force_download = TRUE, # Updates the previously downloaded .osm.pbf file (default is FALSE)
  force_vectortranslate = TRUE, # Forces the vectorization of a .pbf file to .gpbf even if there is a .gpbf file with the same name (default = FALSE)
  extra_tags = et # non-default tags to download
)

# have a look at the data
leeds |> dplyr::glimpse()

# also it's useful to have a look at the downloaded data by plotting it 
# it helps to 
tmap::tm_shape(leeds |> dplyr::filter(!is.na("highway")))+
  tmap::tm_lines(col = "highway")
```

Strangely (or not!) our Leeds data actually represents the whole of West Yorkshire and not only Leeds as we requested.
Such bugs happen, that's why it's important to inspect data before proceeding further.

## Spatial subsetting

Next we will subset Leeds city from `leeds` dataset.
Spatial subsetting is one of the essential operations in geocomputation, so if you want to learn more about this, check out ["Spatial subsetting"](https://geocompr.robinlovelace.net/spatial-operations.html#spatial-subsetting) section in the Geocomputation with R (Lovelace et al., 2022).

We will use a combination of `mapview` and `mapedit` packages to manually define an area, get its coordinates to perform spatial subsetting.

```{r, eval = F}
map_leeds = mapview::mapview(leeds) # create an object containing interactive map  
map_leeds_edit = mapedit::editMap(map_leeds) # use `mapedit` package to draw a new polygon
box = sf::st_bbox(map_leeds_edit$drawn$geometry) # extract the coordinates of a new polygon
box
```

Now we have coordinates of an area we are interested in.
From here on there are two ways for getting OSM data for that.
One is to use `oe_get()` again and give it an additional `boundary` and `boundary_type` arguments.

```{r, eval = F}
leeds_defined = osmextract::oe_get(
  place = "Leeds", # Note capital 'L'!
  provider = "bbbike", # Indicates the provider; default is geofabrik
  layer = "lines", # Default; returns linestring geometries (highways, waterways, aerialways) 
  force_download = TRUE, # Updates the previously downloaded .osm.pbf file (default is FALSE)
  force_vectortranslate = TRUE, # Forces the vectorization of a .pbf file to .gpbf even if there is a .gpbf file with the same name (default = FALSE)
  extra_tags = et, # non-default tags to download
  boundary = box,
  boundary_type = "clipsrc"
)
```

Alternatively, we can subset the `leeds` data, so we do not have to download data again.

```{r, eval = F}
leeds_defined2 = leeds[map_leeds_edit$drawn$geometry, 
                       op= sf::st_intersects] 
```

**Task**:

1.  Decide which tags you would like to download (be selective!)
2.  Download OSM data for a place of your choice by modifying the code above.
3.  Bonus: subset your dataset and plot it.

Note: not every city/town/region might be directly queried using osmextract.

# Data exploration

As alluded in the previous section, it is important to understand the data before using it for further (spatial) analysis or inform decision-making.

In this section you will be introduced to data filtering based on OSM tags and how to visualise them.

## Data filtering

Our data contains a lot of information, but not all of it might be needed.
For example, active travel includes cycling, walking, and wheeling, but you may only be interested in cycling.
In this case it would be reasonable to contain only data that is related to cycling.
In other words, we may not need data on waterways or motorways as one cannot cycle on them.

```{r, eval = FALSE}
# filter out all the rows that do not contain highways
leeds_highways = leeds_defined2 |> 
  dplyr::filter(!is.na(highway))
```

Our data now only contains highways in Leeds, but we want to create a new dataset containing highway=cycleway only and then visualise them by plotting on a map.

```{r, eval = FALSE}
# filter and select
leeds_cycleway = leeds_highways |> 
  dplyr::filter(highway == "cycleway") |> # filtering based on a key value
  dplyr::select(highway)

# plot
leeds_cycleway |> plot()
```

Of course, highway=cycleway does not represent an entire cycling infrastructure in the given region.
For this we need to apply more complex (conditional) filtering to our data.

For example, you may know that it is illegal to cycle on certain roads, such as motorways in the UK.
Also, it may be a case that a cycleway is not mapped separately but, rather, has been tagged as part of another highway, such as tertiary road, using `bicycle=*` tag.

```{r, eval = FALSE}
# To filter data based on these requirements we will:

leeds_cycle = leeds_highways |> 
  dplyr::filter(highway == "cycleway" |
                bicycle %in% c('yes'))  

# let's plot our new cycle network
leeds_cycle["geometry"] |> plot()
```

**Task**:

1. Think what other tags and/or their values might be useful to define cycling network. Use them to further refine the network and plot it.
2. Do you think your new network accurately represents the existing network?
3. What do you think are potential challenges in defining a network? (eg. missing data)
4. Bonus: try to define a pedestrian network.

## Pre-defined networks

It's not easy to define a network and, once conceptualised, a lack of data might still lead to innacurate representation, thus limiting further analysis and application.

Nevertheless, it's still useful to have a network defined. For instance, `osmextract` does offer an opportunity to download pre-defined walking, cycling, or driving networks. Yet, if you choose to do this, do check the code used to create the network to ensure that you understand how the network has been defined and that it works for your needs.

```{r, eval = F}
# to download cycling network as defined by `osmextract`
osme_cycle = osmextract::oe_get_network(place = "Leeds",
                                        mode = "cycling")
```

```{r, eval = F}
# plot cycling network
osme_cycle["geometry"] |>
  plot()
```

# Visualisation

In this workshop we've been visualizing our data to improve our understanding. Up to this point we've been visualising data statically using base R `plot()` function. However, there is a powerful `tmap` library that can be used to create static and interactive plots to communicate your findings.

```{r, eval = F}
# equivalent to the earlier plotted map
# Note: it might be useful to store your plot as a tmap object that can be called at any point.

osme_cycle_plot = tmap::tm_shape(osme_cycle["geometry"])+
  tmap::tm_lines()
```

To plot an interactive map you have to specify this using `tmap_mode()` function. 

```{r, eval = F}
tmap::tmap_mode("view") # now all the plots will be interactive
tmap::tm_shape(osme_cycle)+
  tmap::tm_lines("highway")
```

**Task**:

1. Plot an interactive map of a network you defined in the previous task.
2. Create a `tmap` object of a static map. Tip: run `?tmap_mode()` to access function's documentation.
3. Bonus: Save your new tmap object. Tip: explore `tmap_save()` function.

# OpenInfra

In this section we are going to explore OpenInfra package and some of the functions it currently contains.

One of the functions that the pakcage has is `oi_recode_road_class()`. It recategorises OSM highways based on the Chan and Cooper's (2019) work in which they propose that road class can be used to infer motor traffic volume. Road traffic volume is an important factor in discouraging cycling. 

```{r, eval = F}
leeds_high_rec = leeds_defined2 |> 
  openinfra::oi_recode_road_class()
```

```{r, eval = F}
tmap::tm_shape(leeds_high_rec)+
  tmap::tm_lines("oi_road_desc")
```

Another important consideration in the context of cycling is the maxspeed of motor vehicles as lower motor vehicle speed is associated with lower driver-cyclist road crashes.

```{r, eval = F}
leeds_speed_rec = leeds_defined2 |> 
  openinfra::oi_clean_maxspeed_uk()
```

```{r, eval = F}
tmap::tm_shape(leeds_speed_rec)+
  tmap::tm_lines("oi_maxspeed")
```

We know that in the UK it recommended to have some kind of segregation (eg. lines, tracks) if maxspeed of a motor vehicle is allowed to exceed 30mph. Therefore, we might want to find out if the existing cycling infrastructure complies with the requirements for roads that have maxspeed of 30mph and over.

```{r, eval = F}
# Note: that this is simplification of an above example and does not take into consideration .
leeds_seg = leeds_speed_rec |> dplyr::filter(oi_maxspeed != "20 mph" &
                                               cycleway %in% c("lane", "track", "left") |
                                               highway == "cycleway")
```

```{r, eval = F}
tmap::tm_shape(leeds_seg["geometry"]) + 
  tmap::tm_lines()
```

**Task**: Modify the above example, apply to your data, and then plot it. What does it say about the existing cycling infrastructure?

# A/B Street

A/B Street is an open-source transport traffic and planning simulation software that supports the exploration of "small changes to roads affect cyclists, transit users, pedestrians, and drivers."

This section reuses the ["Visualising cycling potential with A/B Street" vignette](https://a-b-street.github.io/abstr/articles/pct_to_abstr.html) to demonstrate how OSM cycling potential can be visualised with A/B Street.

This is an advanced topic, thus do not worry if you cannot understand everything in this section -- take your time and ask questions if you feel stuck!

Also, ee will make use of an additional R packages: [`pct`](https://itsleeds.github.io/pct/articles/pct.html) and [`abstr`](https://a-b-street.github.io/abstr/index.html) which provides an interface to the A/B Street.

```{r, eval = F}
# install additional packages
install.packages("pct")
install.packages("abstr")
```


```{r, eval = F}
# select a region 
pct::pct_regions$region_name
region_name = "west-yorkshire"

# select (if you want) a local authority in a given area; we will be focusing on Leeds
lookup = pct::pct_regions_lookup
table(lookup$lad16nm[lookup$region_name == region_name])
lad_name = "Leeds" 
```

```{r, eval = F}
# get pct data
wy_zones = pct::get_pct_zones(region = region_name, geography = "lsoa") # get zone data
# filter for Leeds
leeds_zones = wy_zones |>  dplyr::filter(lad_name == "Leeds") |> 
  dplyr::select(geo_code) 
# get commute od data
leeds_commute_od = pct::get_pct_lines(region = region_name, geography = "msoa") |> 
  dplyr::filter(lad_name1 == "Leeds" & lad_name2 == "Leeds") # filter for Leeds
```

```{r, eval = F}
leeds_commute_od = leeds_commute_od |> 
  dplyr::mutate(cycle_base = bicycle) |> 
  dplyr::mutate(walk_base = foot) |> 
  dplyr::mutate(transit_base = bus + train_tube) |>  # bunch of renaming 
  dplyr::mutate(drive_base = car_driver + car_passenger + motorbike + taxi_other) |> 
  dplyr::mutate(all_base = all) |> 
  dplyr::mutate(
    # create new columns
    pcycle_godutch_uptake = pct::uptake_pct_godutch_2020(distance = rf_dist_km, gradient = rf_avslope_perc),
    cycle_godutch_additional = pcycle_godutch_uptake * drive_base,
    cycle_godutch = cycle_base + cycle_godutch_additional,
    pcycle_godutch = cycle_godutch / all_base,
    drive__godutch = drive_base - cycle_godutch_additional,
    dplyr::across(c(drive__godutch, cycle_godutch), round, 0),
    all_go_dutch = drive__godutch + cycle_godutch + transit_base + walk_base
  ) |> 
  dplyr::select(
    # select variables for the new df
    geo_code1,
    geo_code2,
    cycle_base,
    drive_base,
    walk_base,
    transit_base,
    all_base,
    all_go_dutch,
    drive__godutch,
    cycle_godutch,
    cycle_godutch_additional,
    pcycle_godutch
  )
```

```{r, eval = F}
# get OSM building data 
osm_polygons = osmextract::oe_read(
  "https://download.geofabrik.de/europe/great-britain/england/west-yorkshire-latest.osm.pbf",
  # download osm buildings for region using geofabrik
  layer = "multipolygons"
)

building_types = c(
  "yes",
  "house",
  "detached",
  "residential",
  "apartments",
  "commercial",
  "retail",
  "school",
  "industrial",
  "semidetached_house",
  "church",
  "hangar",
  "mobile_home",
  "warehouse",
  "office",
  "college",
  "university",
  "public",
  "garages",
  "cabin",
  "hospital",
  "dormitory",
  "hotel",
  "service",
  "parking",
  "manufactured",
  "civic",
  "farm",
  "manufacturing",
  "floating_home",
  "government",
  "bungalow",
  "transportation",
  "motel",
  "manufacture",
  "kindergarten",
  "house_boat",
  "sports_centre"
)
osm_buildings  = osm_polygons |> 
  dplyr::filter(building %in% building_types) |> 
  dplyr::select(osm_way_id, name, building)

osm_buildings_valid = osm_buildings[sf::st_is_valid(osm_buildings), ]

leeds_osm_buildings_all = osm_buildings_valid[leeds_zones, ]
```

```{r, eval = F}
# join OSM buildings data with leeds zones
leeds_osm_buildings_all_joined = leeds_osm_buildings_all  |> 
  sf::st_join(leeds_zones)

leeds_osm_buildings_sample = leeds_osm_buildings_all_joined  |> 
  dplyr::filter(!is.na(osm_way_id))

leeds_osm_buildings_tbl = leeds_osm_buildings_all  |> 
  dplyr::filter(osm_way_id %in% leeds_osm_buildings_sample$osm_way_id)
```

```{r, eval = F}
# Now rename mode columns to match A/B Street documentation for scenario generation
set.seed(2021) # for reproducible builds
go_dutch = TRUE
if (go_dutch == TRUE) {
  leeds_od = leeds_commute_od  |> 
    dplyr::mutate(All = all_go_dutch)  |> 
    dplyr::mutate(Bike = cycle_godutch)  |> 
    dplyr::mutate(Transit = transit_base)  |> 
    dplyr::mutate(Drive = drive_base) |> 
    dplyr::mutate(Walk = walk_base) |> 
    dplyr::select(geo_code1, geo_code2, All, Bike, Transit, Drive, Walk,geometry)
} else {
  leeds_od = leeds_commute_od  |> 
    dplyr::mutate(All = all_base)  |> 
    dplyr::mutate(Bike = cycle_base)  |> 
    dplyr::mutate(Drive = drive_base)  |> 
    dplyr::mutate(Transit = transit_base) |> 
    dplyr::mutate(Walk = walk_base) |> 
    dplyr::select(geo_code1, geo_code2, All, Bike, Transit, Drive, Walk, geometry)
}
```

```{r, eval = F}
# Let's generate A/B Street scenario!

output_sf = abstr::ab_scenario(
  od = leeds_od,
  zones = leeds_zones,
  zones_d = NULL,
  origin_buildings = leeds_osm_buildings_tbl,
  destination_buildings = leeds_osm_buildings_tbl,
  pop_var = 3,
  time_fun = ab_time_normal,
  output = "sf",
  modes = c("Walk", "Bike", "Drive", "Transit")
)
```

```{r, eval = F}
# generate a JSON file
output_json = abstr::ab_json(output_sf, time_fun = ab_time_normal, scenario_name = "Go Dutch")
# save the file locally
abstr::ab_save(output_json, f = "dutch.json")
```

**Task**: you have created a simulation! Now your task it to visualise it using A/B Street. To do so, follow ["Importing scenario files into A/B Street"](https://a-b-street.github.io/abstr/articles/pct_to_abstr.html#importing-scenario-files-into-ab-street)

# Next steps

First, well done for completing the vignette!












