---
title: "An introduction to OSM data for transport planning"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to OSM data for transport planning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE
)
```

```{r setup, echo = FALSE}
# library(openinfra)
```

# Getting and using OSM data

In this section we will focus on two aspects necessary to work with OpenStreetMap (OSM) data:

1. Downloading OSM data using command line
2. Plotting OSM data to understand what we downloaded

The ability to download OSM data via command line might sound more intimidating compared to Graphical User Interface (GUI) but it can provide a much more flexible approach to working with OSM, including data analysis which will be covered in the later sections. 

Before we begin, I want to remind the basic structure of OSM tags (if you need a more detailed refresher, see **FINISH**). A *tag* consists of a key and a value (key = value). A value can take both numeric and character values. The tags and their meanings that we will use in this notebook are outlined in the table below.

|Tag |Meaning|
---|---|
|Highway |It refers to the road type|
|Footway | **FINISH**|

# Getting OSM data

Here we will learn how to download OSM data using [osmextract package](https://docs.ropensci.org/osmextract/) in R as we are focusing on R as our go-to programming language.`osmextract` that has been developed to make OSM data more accessible. It returns a well-formatted OSM data that can be used as part of a reproducible research. Another advantage of `osmextract` over, for example, `osmdata` is its capability to download large datasets. To learn more about this, check out its [website](https://docs.ropensci.org/osmextract/).

Finally, while `osmextract` offers several different functions to download, read, and translate OSM data, there is no one best function and the choice depends on, for example, whether you already have a dataset that needs to be read or translated. In this section it will be assumed that you want to download the OSM data. For this, two functions will be demonstrated:

1. oe_get()
2. oe_get_network()

In this section we will only touch upon the basics, so if you want to learn more about the package, go through the [Get Started](https://docs.ropensci.org/osmextract/articles/osmextract.html) article published on the `osmextract` website.

```{r}
# Before we start, we need to load the libraries that we will be using throughout the practical.
library(tidyverse)
library(sf)
library(osmextract)

# If you do not have these libraries installed, then run the following code (uncomment first) and load them again:
# pkgs = c("tidyverse",
#          "sf",
#          "osmextract")
# install.packages(pkgs)
```


## Downloading OSM network with osmextract::oe_get()

oe_get() is perhaps the core function in the package and the one I would recommend starting from because it is quite straightforward once introduced.

```{r, results = FALSE}
?osmextract::oe_get() # Documentation of a function

# The first step is to define the place. In this case it is Leeds
# A useful function is oe_match_pattern() to search for patterns in a provider's database. It is helpful in indicating a correct region name for a given provider.
osmextract::oe_match_pattern("leeds") 
osmextract::oe_match_pattern("yorkshire") # "yorkshire" is associated with several different geographic zones.
region_leeds = "Leeds" # Note the capital L. The function in which the object will be used is not case sensitive but I would still recommend using the exact string to minimize the likelihood of an error.

leeds = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", # Indicates the provider; default is geofabrik
  layer = "lines", # Default; returns linestring geometries (highways, waterways, aerialways) 
  force_download = TRUE, # Updates the previously downloaded .osm.pbf file (default is FALSE)
  force_vectortranslate = TRUE # Forces the vectorization of a .pbf file to .gpbf even if there is a .gpbf file with the same name (default = FALSE)
)
```

- If you are curious, you can check out what happens when you input "leeds" instead of "Leeds" and provider is not specified (uncomment `leeds_test` object in the code chunk below).
```{r, results = FALSE}
# leeds_test = osmextract::oe_get(
#   place = "leeds",
#   force_download = TRUE, 
#   force_vectortranslate = TRUE
# )

#> No exact match found for place = leeds and provider = geofabrik. Best match is Laos. Checking the other providers. An exact string match was found using provider = bbbike.
# Even though there was no exact string match (i.e., leeds) for a default provider, it still returned the dataset we needed by switching the provider. In this case it is fine, but it could cause problems for, for instance, "yorkshire" (test it out if you are up for a little challenge).
```

## Downloading OSM network with osmextract::oe_get_network()

This function is a quick and useful way of returning a desired road network. However, it is important to point out that (compared to `oe_get()`) some filtering is being done before returning the network. Thus, it is important to understand *what* kind of network is exactly returned and if that suits your particular needs.

```{r, results = FALSE}
leeds_net_walking = osmextract::oe_get_network(
  place = region_leeds,
  mode = "walking", # What mode of transport is to be returned? Default is cycling
  provider = "bbbike",
  force_download = TRUE,
  force_vectortranslate = TRUE
)
```

## Comparing both approaches

If you have a look at both datasets, you will notice that `leeds` has more observations (rows). This is because of filtering done prior to returning the network. Yet, `leeds_net_walking` has more columns. This is because oe_get_network filtering relies on tags that are not, by default, returned as columns when oe_get() is used. 

```{r}
# checking out the dimensions of both datasets
leeds %>% dim()
leeds_net_walking %>% dim()

# returning column names
leeds_names = leeds %>% names()
leeds_net_walking_names = leeds_net_walking %>% names()

# returning column names that are in the `leeds_net_walking` but not `leeds`
setdiff(leeds_net_walking_names, 
     leeds_names)
```

If you look at the documentation, you will notice that additional *access*, *foot*, and *service* tags are used to define a pedestrian network.

In the following subsection we will learn how to get those extra tags (and many more) using `oe_get` function that would allow you to define your own network.

## extra tags

Have you noticed "other_tags" column in the `leeds` and `leeds_net_walking` datasets? This is where various additional tags are stored that can be utilized. OSM has hundreds of them and there is a useful function in `osmextract` that allows you to browse through them. I would recommend spending some time exploring the variety of tags that you think might be relevant to your particular task.

```{r}
# checking the keys that are stored in the 'extra_tags' column
osmextract::oe_get_keys(leeds)
```

To download a dataset that has tags as columns (i.e., not stored in the 'extra_tags' column), we can take advantage of the 'extra_tags' argument.

```{r, results = FALSE}
# The first step is to create a character vector with all the tags we want to be returned.
tags_needed = c("access",
                "foot",
                "service")

leeds_tn = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", 
  layer = "lines", 
  force_download = TRUE, 
  force_vectortranslate = TRUE,
  extra_tags = tags_needed
)
leeds_tn_test = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", 
  layer = "lines", 
  force_download = TRUE, 
  force_vectortranslate = TRUE,
  extra_tags = tags_needed,
  vectortranslate_options = c(
    "-where", "
    ((highway IS NOT NULL AND highway NOT IN (
    'abandonded', 'bus_guideway', 'byway', 'construction', 'corridor', 'elevator',
    'fixme', 'escalator', 'gallop', 'historic', 'no', 'planned', 'platform',
    'proposed', 'raceway', 'motorway', 'motorway_link'
    )) OR (
    highway = 'cycleway' AND foot = 'yes'
    ))
    AND
    (access IS NULL OR access NOT IN ('private', 'no') OR foot = 'yes')
    "
    )
)
leeds_tn_test2 = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", 
  layer = "lines", 
  force_download = TRUE, 
  force_vectortranslate = TRUE,
  extra_tags = tags_needed,
  vectortranslate_options = c(
    "-where", "
    ((highway IS NOT NULL AND highway NOT IN (
    'abandonded', 'bus_guideway', 'byway', 'construction', 'corridor', 'elevator',
    'fixme', 'escalator', 'gallop', 'historic', 'no', 'planned', 'platform',
    'proposed', 'raceway', 'motorway', 'motorway_link'
    )) OR (
    highway = 'cycleway' AND foot = 'yes'
    ))
    AND
    (access IS NULL OR access NOT IN ('private', 'no') OR foot = 'yes')
    AND
    (foot IS NULL OR foot NOT IN ('private', 'no', 'use_sidepath', 'restricted'))
    "
    )
)
```

```{r}
# Let's check if we have those 3 tags as columns
leeds_tn %>% names
leeds_tn_test %>% nrow

# right now we have the information needed to return a pedestrian network as defined by the `oe_get_network` function
highway_not = c("abandonded", "bus_guideway", "byway", "construction", "corridor", "elevator", "fixme", "escalator", "gallop", "historic", "no", "planned", "platform", "proposed", "raceway", "motorway", "motorway_link")

'%!in%' = Negate('%in%')                
leeds_tn_subset = leeds_tn %>% 
  filter(!is.na(highway) &  highway %!in% highway_not |  highway == "cycleway" & foot == "yes") %>% 
  filter(is.na(access) | access %!in% c("no", "private") | foot == "yes") 

leeds_tn_subset2 = leeds_tn %>% 
  filter(!is.na(highway) &  highway %!in% highway_not |  highway == "cycleway" & foot == "yes") %>% 
  filter(is.na(access) | access %!in% c("no", "private") | foot == "yes") %>% 
  filter(is.na(foot) | foot %!in% c('private', 'no', 'use_sidepath', 'restricted'))

leeds_tn_test %>% dim()
leeds_tn_subset %>% dim()
leeds_tn_test2 %>% dim()
leeds_tn_subset2 %>% dim()
```


The `extra_tags` argument can also be used with `oe_get_network` function.
```{r, results = FALSE}
tags_needed1 = c("footway")
leeds_net_walking_tn1 = osmextract::oe_get_network(
  place = region_leeds,
  mode = "walking", # What mode of transport is to be returned? Default is cycling
  provider = "bbbike",
  force_download = TRUE,
  force_vectortranslate = TRUE,
  extra_tags = tags_needed1
)
```

There is another way of adding tags -- by re-creating the .gpkg file using `oe_vectortranslate()` (see [here](https://docs.ropensci.org/osmextract/articles/osmextract.html)) however this might be a less intuitive approach. So I would recommend, especially if you are a beginner, using 'extra_tags' argument as part of the `oe_get` or `oe_get_network` function.



# Saving OSM data

You have learnt how to download the desired dataset but, most likely, you do not want to have to download it every single as it can be time-consuming. Good news is that you can save the dataset as an RDS file and, if needed, share it with other R users. 

```{r, echo = FALSE, results=FALSE}
# to save in your working directory. If you do not know where your working directory is, type `getwd()` to your console.
saveRDS(leeds, # name of an object in R
        "leeds.RDS") # name of a file (note the .RDS extension)
saveRDS(leeds_net_walking,
        "leeds_net_walking.RDS")
saveRDS(leeds_tn,
        "leeds_tn.RDS")
saveRDS(leeds_net_walking_tn1,
        "leeds_net_walking_tn1.RDS")

# to import
readRDS("leeds_tn.RDS") # file name
leeds_tn = readRDS("leeds_tn.RDS") # import and save as an object; 
leeds_net_walking_tn1 = readRDS("leeds_net_walking_tn1.RDS")
```



Exercises:

- download active travel network for your city or region (other than Leeds).
- save the other 3 downloaded datasets.


to finish:

- add info on installing libraries
- table
- insert link to notebook 1 (what is osm?)
- explain why I'm using force_vectortranslate and force_download
  - to update the previously downloaded files (there is constantly new data being added to OSM so it's important to keep our data updated to take advantage of crowdsourced nature of OSM) [chunk 4]
- mention that other programming languages can also be used, such as Python and [OSMnx package](https://osmnx.readthedocs.io/en/stable/#) or rust as in [A/B Street](https://github.com/a-b-street/abstreet#ab-street).

