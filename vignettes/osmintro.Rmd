---
title: "An introduction to OSM data for transport planning"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to OSM data for transport planning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE
)
```

```{r setup, echo = FALSE}
# library(openinfra)
```

# Getting and using OSM data

In this section we will focus on two aspects necessary to work with OpenStreetMap (OSM) data:

1. Downloading OSM data using command line
2. Plotting OSM data to understand what we downloaded

The ability to download OSM data via command line might sound more intimidating compared to Graphical User Interface (GUI) but it can provide a much more flexible approach to working with OSM, including data analysis which will be covered in the later sections. 

Before we begin, I want to remind the basic structure of OSM tags (if you need a more detailed refresher, see **FINISH**). A *tag* consists of a key and a value (key = value). A value can take both numeric and character values. The tags and their meanings that we will use in this notebook are outlined in the table below.

|Tag |Meaning|
---|---|
|Highway |It indicates the road type ([link](https://wiki.openstreetmap.org/wiki/Key:highway))|
|Foot| Provides information on  the legal access for pedestrians ([link](https://wiki.openstreetmap.org/wiki/Key:foot))|
|Access| Provides information on the legal permissions and restrictions  ([link](https://wiki.openstreetmap.org/wiki/Key:access))|
|Service| Provides additional information on the services (roads, businesses)  ([link](https://wiki.openstreetmap.org/wiki/Key:service)|

# Getting OSM data

Here we will learn how to download OSM data using [osmextract package](https://docs.ropensci.org/osmextract/) in R. `osmextract` that has been developed to make OSM data more accessible. It returns a well-formatted OSM data that can be used as part of a reproducible research. Another advantage of `osmextract` over, for example, `osmdata` is its capability to download large datasets. To learn more about this, check out its [website](https://docs.ropensci.org/osmextract/).

`osmextract` offers several different functions to download, read, and translate OSM data, there is no one best function and the choice depends on, for example, whether you already have a dataset that needs to be translated. In this section it will be assumed that you want to download the OSM data. For this, two functions will be demonstrated:

1. oe_get()
2. oe_get_network()

In this section we will only touch upon the basics, so if you want to learn more about the package, go through the [Get Started](https://docs.ropensci.org/osmextract/articles/osmextract.html) article published on the `osmextract` website.

```{r}
# Before we start, we need to load the libraries that we will be using throughout the practical.
library(tidyverse)
library(sf)
library(osmextract)

# If you do not have these libraries installed, then run the following code (uncomment first) and load them again:
# pkgs = c("tidyverse",
#          "sf",
#          "osmextract")
# install.packages(pkgs)
```


## Downloading OSM network with osmextract::oe_get()

oe_get() is perhaps the core function in the package and the one I would recommend starting from because it is quite straightforward once introduced, yet versatile enough to meet the needs of an advanced user.

```{r, results = FALSE}
?osmextract::oe_get() # Documentation of a function

# The first step is to define the place. In this case it is Leeds.
# A useful function is oe_match_pattern() to search for patterns in a provider's database. It is helpful in indicating a correct region name for a given provider.
osmextract::oe_match_pattern("leeds") 
osmextract::oe_match_pattern("yorkshire") # "yorkshire" is associated with several different geographic zones.
region_leeds = "Leeds" # Note the capital L. The function in which the object will be used is not case sensitive but I would still recommend using the exact string to minimize the likelihood of an error.

leeds = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", # Indicates the provider; default is geofabrik
  layer = "lines", # Default; returns linestring geometries (highways, waterways, aerialways) 
  force_download = TRUE, # Updates the previously downloaded .osm.pbf file (default is FALSE)
  force_vectortranslate = TRUE # Forces the vectorization of a .pbf file to .gpbf even if there is a .gpbf file with the same name (default = FALSE)
)
```

- If you are curious, you can check out what happens when you input "leeds" instead of "Leeds" if the provider is not specified (uncomment `leeds_test` object in the code chunk below).
```{r, results = FALSE}
# leeds_test = osmextract::oe_get(
#   place = "leeds",
#   force_download = TRUE, 
#   force_vectortranslate = TRUE
# )

#> No exact match found for place = leeds and provider = geofabrik. Best match is Laos. Checking the other providers. An exact string match was found using provider = bbbike.
# Even though there was no exact string match (i.e., leeds) in a default provider, it still returned the dataset we needed by switching the provider. In this case it is fine, but it could cause problems for, for instance, "yorkshire" (test it out if you are up for a little challenge).
```

## Downloading OSM network with osmextract::oe_get_network()

This function is a quick and useful way of returning a desired road network. However, it is important to point out that (compared to `oe_get()`) some filtering is being done before returning the network. Thus, it is important to understand *what* kind of network is exactly returned and if that suits your particular needs.

```{r, results = FALSE}
leeds_net_walking = osmextract::oe_get_network(
  place = region_leeds,
  mode = "walking", # What mode of transport is to be returned? Default is cycling
  provider = "bbbike",
  force_download = TRUE,
  force_vectortranslate = TRUE
)
```

## Comparing both approaches

If you have a look at both datasets, you will notice that `leeds` has more observations (rows). This is because of filtering done prior to returning the network. Yet, `leeds_net_walking` has more columns. This is because oe_get_network filtering relies on tags that are not, by default, returned as columns when oe_get() is used. 

```{r}
# checking out the dimensions of both datasets
leeds %>% dim()
leeds_net_walking %>% dim()

# returning column names
leeds_names = leeds %>% names()
leeds_net_walking_names = leeds_net_walking %>% names()

# returning column names that are in the `leeds_net_walking` but not `leeds`
setdiff(leeds_net_walking_names, 
     leeds_names)
```

If you look at the [documentation](https://github.com/ropensci/osmextract/blob/master/R/get-network.R), you will notice that additional *access*, *foot*, and *service* tags are used to define a pedestrian network.

In the following subsection we will learn how to get those extra tags (and many more) using `oe_get` function that would allow you to define your own network.

## extra tags

Have you noticed "other_tags" column in the `leeds` and `leeds_net_walking` datasets? This is where various additional tags are stored that can be utilized. OSM has hundreds of them and there is a useful function in `osmextract` that allows you to browse through them. I would recommend spending some time exploring the variety of tags that you think might be relevant to your particular task.

```{r}
# checking the keys that are stored in the 'extra_tags' column
osmextract::oe_get_keys(leeds)
```

To download a dataset that has tags as columns (i.e., not stored in the 'extra_tags' column), we can take advantage of the 'extra_tags' argument.

```{r, results = FALSE}
# The first step is to create a character vector with all the tags we want to be returned.
tags_needed = c("access",
                "foot",
                "service")

leeds_tn = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", 
  layer = "lines", 
  force_download = TRUE, 
  force_vectortranslate = TRUE,
  extra_tags = tags_needed
)
leeds_tn_test = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", 
  layer = "lines", 
  force_download = TRUE, 
  force_vectortranslate = TRUE,
  extra_tags = tags_needed,
  vectortranslate_options = c(
    "-where", "
    ((highway IS NOT NULL AND highway NOT IN (
    'abandonded', 'bus_guideway', 'byway', 'construction', 'corridor', 'elevator',
    'fixme', 'escalator', 'gallop', 'historic', 'no', 'planned', 'platform',
    'proposed', 'raceway', 'motorway', 'motorway_link'
    )) OR (
    highway = 'cycleway' AND foot = 'yes'
    ))
    AND
    (access IS NULL OR access NOT IN ('private', 'no') OR foot = 'yes')
    "
    )
)
leeds_tn_test2 = osmextract::oe_get(
  place = region_leeds,
  provider = "bbbike", 
  layer = "lines", 
  force_download = TRUE, 
  force_vectortranslate = TRUE,
  extra_tags = tags_needed,
  vectortranslate_options = c(
    "-where", "
    ((highway IS NOT NULL AND highway NOT IN (
    'abandonded', 'bus_guideway', 'byway', 'construction', 'corridor', 'elevator',
    'fixme', 'escalator', 'gallop', 'historic', 'no', 'planned', 'platform',
    'proposed', 'raceway', 'motorway', 'motorway_link'
    )) OR (
    highway = 'cycleway' AND foot = 'yes'
    ))
    AND
    (access IS NULL OR access NOT IN ('private', 'no') OR foot = 'yes')
    AND
    (foot IS NULL OR foot NOT IN ('private', 'no', 'use_sidepath', 'restricted'))
    "
    )
)
```

```{r}
# Let's check if we have those 3 tags as columns
leeds_tn %>% names
leeds_tn_test %>% nrow

# right now we have the information needed to return a pedestrian network as defined by the `oe_get_network` function
highway_not = c("abandonded", "bus_guideway", "byway", "construction", "corridor", "elevator", "fixme", "escalator", "gallop", "historic", "no", "planned", "platform", "proposed", "raceway", "motorway", "motorway_link")

'%!in%' = Negate('%in%')                
leeds_tn_subset = leeds_tn %>% 
  filter(!is.na(highway) &  highway %!in% highway_not |  highway == "cycleway" & foot == "yes") %>% 
  filter(is.na(access) | access %!in% c("no", "private") | foot == "yes") 

leeds_tn_subset2 = leeds_tn %>% 
  filter(!is.na(highway) &  highway %!in% highway_not |  highway == "cycleway" & foot == "yes") %>% 
  filter(is.na(access) | access %!in% c("no", "private") | foot == "yes") %>% 
  filter(is.na(foot) | foot %!in% c('private', 'no', 'use_sidepath', 'restricted'))

leeds_tn_test %>% dim()
leeds_tn_subset %>% dim()
leeds_tn_test2 %>% dim()
leeds_tn_subset2 %>% dim()
```


The `extra_tags` argument can also be used with `oe_get_network` function.
```{r, results = FALSE}
tags_needed1 = c("footway")
leeds_net_walking_tn1 = osmextract::oe_get_network(
  place = region_leeds,
  mode = "walking", # What mode of transport is to be returned? Default is cycling
  provider = "bbbike",
  force_download = TRUE,
  force_vectortranslate = TRUE,
  extra_tags = tags_needed1
)
```

There is another way of adding tags -- by re-creating the .gpkg file using `oe_vectortranslate()` (see [here](https://docs.ropensci.org/osmextract/articles/osmextract.html)) however this might be a less intuitive approach. So I would recommend, especially if you are a beginner, using 'extra_tags' argument as part of the `oe_get` or `oe_get_network` function.

# Plotting OSM data

Plotting, or mapping, might seem like something done to visualize the end results, but it is also incredibly useful throughout the data science project. Indeed, Beenchman and Lovelace (2022) argue that visualizations can be central to making inferences in geographical analysis. Given that, this section aims to introduce you to two simple techniques for mapping:

1. static maps with base R
2. interactive maps with `mapview` library

## static maps with base R

Base R `plot` function is great for plotting on-the-go as it is quick and pretty intuitive. It is great to get a general sense of the data and its structure which, then, can be used to inform further decisions.

```{r}
# Let's plot all the highways that have a non-NA value in the `foot` column:
plot(leeds_tn['foot'])
# If we want to map only a specific value of a column:
plot(leeds_tn[leeds_tn$foot == "yes", "foot"]) # returning only "yes" values in `foot`

# the tidy approach would be:
leeds_tn %>% select(foot) %>% plot() # all non_NA values 
leeds_tn %>% filter(foot == "yes") %>% select(foot) %>% plot() # returning only "yes" values in `foot`
```

### saving

You might want to save the images of a plot for later use. To do this, you can use "Export" functionality just above the image or use command line.
```{r}
# command line approach to saving base R plots in a png format
png(file = "plot_foot.png") # a name of an image to be created (not the .png extension)
plot(leeds_tn['foot']) # plot
dev.off() # closes the file
# the image should have been saved in your working directory
```

## interactive maps with `mapview`

`mapview` is a package that allows to quickly produce interactive spatial visualisations. Let's turn our static maps into the interactive ones.

```{r}
mapview::mapview(leeds_tn["foot"])
```

The function allows to examine data in the context which, again, aids one's understanding of the data at hand. What is immediately visible from the visualisation is that there is a great number of NAs, which means that the data is missing.
```{r}
# Dropping missing values in the `foot` column
mapview::mapview(na.omit(leeds_tn["foot"]))

# However the "cleanest" approach to plotting non-NA foot values might be to create a new object that will be fed to the `mapview()` 
leeds_foot_nt = na.omit(leeds_tn["foot"])
mapview::mapview(leeds_foot_nt)

# tidy approach would be:
leeds_foot_tidy = leeds_tn %>% 
  filter(!is.na(foot)) %>% 
  select(foot)
mapview::mapview(leeds_foot_tidy)
```

### Saving

In theory, it should be possible to use `mapshot()` function to save `mapview` plots as an .html, .png, .pdf, or .jpeg file, but in practice it does not always work as desired. 

```{r}
# an example of saving interactive map as html
pretty_map = mapview::mapview(leeds_foot_tidy)
mapview::mapshot(pretty_map, url = paste0(getwd(), "/pretty_map.html"),
                 selfcontained = FALSE
                 )
```

Somewhat of an alternative is to use `webshot` package and take a photo of an interactive map, which might still look nicer compared to the base R plots. 

```{r}
webshot::webshot("http://localhost:15593/session/viewhtml3bbe19d3ee34/index.html",
        file = "pretty_map.png")
```


# Saving (and importing) OSM data as RDS files

You have learned how to download the desired dataset but, most likely, you do not want to have to download it every single as it can be time-consuming (however, it is a good practice to update it constantly). Good news is that you can save a dataset as an RDS file and, if needed, share it with other (R) users. 

```{r, echo = FALSE, results=FALSE}
# to save in your working directory. If you do not know where your working directory is, type `getwd()` to your console.
saveRDS(leeds, # name of an object in R
        "leeds.RDS") # name of a file (note the .RDS extension)

# to import
readRDS("leeds_tn.RDS")
leeds_tn = readRDS("leeds_tn.RDS") # import and save as an object; 
leeds_net_walking_tn1 = readRDS("leeds_net_walking_tn1.RDS")
```


Exercises:

- download active travel network for your city or region (other than Leeds).
- save the other 3 downloaded datasets.


to finish:

- add info on installing libraries (done)
- table (done)
- insert link to notebook 1 (what is osm?)
- explain why I'm using force_vectortranslate and force_download
  - to update the previously downloaded files (there is constantly new data being added to OSM so it's important to keep our data updated to take advantage of crowdsourced nature of OSM) [chunk 4]
- mention that other programming languages can also be used, such as Python and [OSMnx package](https://osmnx.readthedocs.io/en/stable/#) or rust as in [A/B Street](https://github.com/a-b-street/abstreet#ab-street).
- references
- saving interactive maps

